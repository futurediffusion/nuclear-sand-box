# AGENTS.MD ‚Äî NUCLEAR SAND BOX (Godot 4.x)

## 1Ô∏è‚É£ VISI√ìN DEL PROYECTO

**NUCLEAR SAND BOX** ya no es un prototipo simple de combate.

Ahora es un **sandbox procedural 2D top-down** con:

- Mundo generado por chunks.
- Biomas (arena, pasto, piedra).
- Recursos minables (cobre).
- Campamentos de bandidos.
- Econom√≠a b√°sica (oro + inventario).
- Sistema de stamina + bloqueo direccional.
- Componentes reutilizables (Health, Stamina, Inventory).
- Persistencia de entidades por chunk.
- Arquitectura preparada para escalar a facciones y control territorial.

Objetivo de evoluci√≥n:

- Recursos que generen conflicto.
- NPCs que disputen territorio.
- Mundo persistente y coherente.

---

## 2Ô∏è‚É£ ARQUITECTURA GENERAL

### Escena principal

`scenes/main.tscn`

Contiene:

- `Player`
- `World` (TileMap + chunk system)
- `UI` (HUD + GameOverPanel)
- Sistemas globales conectados a `GameManager`

---

## 3Ô∏è‚É£ SISTEMAS PRINCIPALES

### üåç WORLD SYSTEM (Chunk-Based)

Script principal:

- `scripts/world/world.gd`

Responsabilidades:

- Generaci√≥n procedural por chunks (64x64 por defecto).
- Activaci√≥n/desactivaci√≥n seg√∫n distancia al player.
- Spawn de:
  - Tiles por bioma.
  - Cobre.
  - Campamentos de bandidos.
- Persistencia de entidades por chunk.
- Streaming optimizado.

Caracter√≠sticas:

- Biomas definidos por `FastNoiseLite`.
- Reglas de spawn:
  - M√°s cobre en piedra.
  - Algunos cobres custodiados.
  - Algunos campamentos alejados de cobre.
- Diccionario `chunk_entities`.
- Sistema de save/load por chunk implementado.

‚ö†Ô∏è **Regla importante:**

- Un chunk no debe regenerar entidades si ya fue generado.
- El estado se debe conservar en memoria durante la sesi√≥n.

### ‚õèÔ∏è RECURSOS (Cobre)

Escena:

- `scenes/copper_ore.tscn`

Script:

- `scripts/resources/copper_ore.gd`

Funcionalidad:

- Tiene cantidad restante.
- Puede reproducir sonido de minado.
- Se integra con `InventoryComponent` del player.
- Futuro: ownership/control territorial.

### üèïÔ∏è CAMPAMENTOS DE BANDIDOS

Escena:

- `scenes/bandit_camp.tscn`

Script:

- `scripts/world/bandit_camp.gd`

Rol:

- Punto de spawn controlado.
- Puede generar m√∫ltiples enemigos.
- Algunos aparecen cerca de cobre (custodia).
- Otros aparecen aleatoriamente.

Futuro:

- Centro de control territorial.
- Radio de influencia.
- Producci√≥n de patrullas.

### üßç PLAYER

Script:

- `scripts/gameplay/player.gd`

Componentes usados:

- `HealthComponent`
- `StaminaComponent`
- `InventoryComponent`

Sistemas activos:

- Movimiento con aceleraci√≥n/fricci√≥n.
- Ataque melee con Slash.
- Bloqueo direccional con cono frontal.
- Consumo de stamina.
- Knockback.
- Emisi√≥n de se√±ales para HUD.
- Integraci√≥n con `GameManager` para muerte.

### üß† COMPONENTES REUTILIZABLES

Ubicaci√≥n:

- `scripts/components/`

`HealthComponent`

- `max_hp`
- `hp`
- `armor`
- se√±ales: `damaged`, `died`

`StaminaComponent`

- `max_stamina`
- `regen`
- `attack_cost`
- se√±al `stamina_changed`

`InventoryComponent`

- `gold`
- `items` (`Dictionary`)
- `add_item / remove_item`
- `sell / buy`
- `debug_print()`

‚ö†Ô∏è **Regla:**

- La l√≥gica reusable va en componentes.
- No duplicar sistemas dentro de `Player` o `Enemy`.

### üë• ENEMY REGISTRY (Autoload)

Ubicaci√≥n:

- `scripts/systems/EnemyRegistry.gd`

Rol:

- Registro central de enemigos vivos usando `WeakRef`.
- Evita referencias stale/freed en l√≥gica de separaci√≥n.
- API: `register_enemy`, `unregister_enemy`, `get_live_enemies`, `count`.

### üßæ GameManager (Autoload)

Ubicaci√≥n:

- `scripts/systems/game_manager.gd`

Rol:

- Se√±ales globales.
- `player_died`
- `zone_entered`
- Estado global temporal.
- Evitar acoplamiento directo entre escenas.

---

## 4Ô∏è‚É£ ECONOM√çA ACTUAL (MVP)

- Oro almacenado en `InventoryComponent`.
- Recursos tipo string (`"copper"`).
- Venta y compra funcional v√≠a debug.
- No hay UI de tienda a√∫n.
- No hay persistencia entre sesiones.

Futuro:

- Taberna como hub.
- NPC comerciantes.
- Precios din√°micos.

---

## 5Ô∏è‚É£ REGLAS DE DISE√ëO IMPORTANTES

- El mundo es sist√©mico, no scriptado.
- Recursos generan conflicto.
- No regenerar entidades arbitrariamente.
- Persistencia por chunk es obligatoria.
- Componentes > l√≥gica hardcodeada.
- `GameManager` para eventos globales.
- Evitar rutas absolutas a nodos.
- Usar grupos para localizar entidades din√°micas.

---

## 6Ô∏è‚É£ ESTADO ACTUAL DEL PROYECTO

Implementado:

- ‚úÖ Mundo procedural con biomas.
- ‚úÖ Chunk streaming.
- ‚úÖ Persistencia en sesi√≥n.
- ‚úÖ Cobre minable.
- ‚úÖ Campamentos bandido.
- ‚úÖ Taberna procedural como POI integrado al mundo.
- ‚úÖ Enemigos funcionales.
- ‚úÖ Bloqueo direccional.
- ‚úÖ Stamina.
- ‚úÖ Inventario b√°sico.
- ‚úÖ HUD funcional.
- ‚úÖ Game Over desacoplado.
- ‚úÖ Colisiones de paredes y ajuste visual de transparencia por oclusi√≥n.

Pendiente / futuro inmediato:

- Sistema de facciones.
- Control territorial.
- Sistema de caminos.
- Guardado en disco.
- Econom√≠a real (sin debug).

---

## 7Ô∏è‚É£ ESCALABILIDAD PREVISTA

Arquitectura preparada para:

- Facciones NPC.
- IA que mine recursos.
- Disputas por nodos.
- Patrullas.
- Eventos din√°micos.
- Guardado completo del mundo.

---

## 8Ô∏è‚É£ LO QUE ESTE PROYECTO YA NO ES

- ‚ùå No es solo un prototipo de combate.
- ‚ùå No es un arena brawler.
- ‚ùå No depende de spawner fijo simple.

Es un **sandbox procedural en evoluci√≥n**.

---

## 9Ô∏è‚É£ DIRECTIVA PARA AGENTES / CODEX

Cuando modifiques c√≥digo:

- No romper persistencia de chunks.
- No regenerar entidades si ya existen.
- No duplicar l√≥gica de componentes.
- Mantener separaci√≥n `World / Player / Systems`.
- Si se agrega un sistema nuevo ‚Üí documentarlo aqu√≠.

---

## üîü RECOMENDACIONES PR√ÅCTICAS PARA CONTRIBUIR

Para mantener el proyecto estable y escalable:

- Priorizar cambios peque√±os y verificables por sistema (`world`, `gameplay`, `ui`, `components`).
- Si tocas `world.gd`, validar expl√≠citamente:
  - generaci√≥n inicial,
  - reentrada a chunks ya visitados,
  - no duplicaci√≥n de recursos/camps.
- Si tocas componentes, exponer se√±ales y API m√≠nima para evitar acoplamiento.
- Al agregar contenido sist√©mico nuevo (ej. nuevo recurso o POI), definir:
  - reglas de spawn,
  - interacci√≥n con inventario/econom√≠a,
  - comportamiento al descargar/cargar chunk.
- Mantener este archivo actualizado cuando cambie la realidad jugable del proyecto.
