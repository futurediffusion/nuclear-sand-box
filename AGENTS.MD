# AGENTS.MD ‚Äî Gu√≠a de colaboraci√≥n para **NUCLEAR SAND BOX** (Godot 4.4)

Este documento resume la estructura, escenas, scripts y convenciones del proyecto para que cualquier persona (o IA) pueda mantenerlo y extenderlo r√°pidamente.

---

## 1) üß† Descripci√≥n general del proyecto

### ¬øQu√© es?
**NUCLEAR SAND BOX** es un prototipo de juego 2D top-down en Godot 4.4 centrado en combate cuerpo a cuerpo: controlas un personaje con movimiento WASD, ataque con mouse, enemigos con IA t√°ctica, sangre/part√≠culas, knockback y pantalla de game over.

### Estructura principal de carpetas

- **`/scenes`**
  - Contiene las escenas jugables (`main.tscn`, `player.tscn`, `enemy.tscn`, `slash.tscn`, etc.).
  - Tambi√©n hay archivos temporales `*.tmp` generados por editor/autoguardado. No forman parte del flujo jugable.
  - Nota: existe un script dentro de esta carpeta (`scenes/enemy.gd`), usado por `enemy.tscn`.

- **`/scripts`**
  - Carpeta √∫nica de scripts GDScript del proyecto.
  - Organizada por dominio (`gameplay`, `camera`, `ui`, `fx`, `components`).

- **`/art/sprites`**
  - Sprites de personajes, arma, cursor y sangre.
  - `.import` son metadatos de importaci√≥n de Godot.

- **`/art/Sounds`**
  - SFX de slash y de impacto.

- **Ra√≠z (`project.godot`, `icon.svg`)**
  - Configuraci√≥n de proyecto, InputMap, capas de colisi√≥n y ajustes de ventana/render.

### Grupos de scripts por responsabilidad

- **Core gameplay**: `scripts/gameplay/player.gd`, `scenes/enemy.gd`, `scripts/gameplay/slash.gd`.
- **Spawning/flujo de partida**: `scripts/gameplay/enemy_spawner.gd`, `scripts/gameplay/main.gd`.
- **C√°mara/cursor**: `scripts/camera/camera.gd`, `scripts/ui/cursor_2d.gd`.
- **FX sangre**: `scripts/fx/blood_droplet.gd`, `scripts/fx/blood_burst.gd` (este √∫ltimo parece helper no conectado directamente en escenas actuales).

---

## 2) üß± Mapa de escenas

> Resumen de cada `.tscn` y sus nodos m√°s relevantes.

### `scenes/main.tscn`
**Rol:** escena principal del juego.

Nodos clave:
- `Main (Node2D)` + script `scripts/gameplay/main.gd`: coordina Game Over y retry.
- `BackgroundLayer/ColorRect`: fondo de color.
- `Player` (instancia de `player.tscn`): protagonista.
- `MouseCursor` (instancia de `cursor_2d.tscn`): cursor custom.
- `Enemy` (instancia de `enemy.tscn`): enemigo inicial ya en mapa.
- `EnemySpawner` (instancia de `enemy_spawner.tscn`): spawner peri√≥dico.
- `UI/GameOverPanel` + botones (`RetryButton`, `QUIT`): interfaz de fin de partida (el bot√≥n quit no tiene l√≥gica conectada actualmente).

### `scenes/player.tscn`
**Rol:** prefab del player.

Nodos clave:
- `Player (CharacterBody2D)` + script `scripts/gameplay/player.gd`.
- `AnimatedSprite2D`: animaciones `idle`, `walk`, `hurt`, `death`.
- `CollisionShape2D`: colisi√≥n del cuerpo.
- `WeaponPivot` + `WeaponSprite`: rotaci√≥n visual del arma.
- `SlashSpawn (Marker2D)`: punto de spawn del ataque.
- `Camera2D` + script `scripts/camera/camera.gd`: look-ahead y shake.

### `scenes/enemy.tscn`
**Rol:** prefab de enemigo con IA.

Nodos clave:
- `Enemy (CharacterBody2D)` + script `scenes/enemy.gd`.
- `AnimatedSprite2D`: animaciones del goblin.
- `CollisionShape2D`: colisi√≥n del enemigo.
- `WeaponPivot` + `WeaponSprite`.
- `SlashSpawn`: punto de ataque melee.

### `scenes/enemy_spawner.tscn`
**Rol:** emisor de enemigos.

Nodos clave:
- `EnemySpawner (Node2D)` + script `scripts/gameplay/enemy_spawner.gd`.
- Exporta `enemy_scene`, `spawn_interval`, `max_enemies`, `spawn_radius`.

### `scenes/slash.tscn`
**Rol:** hitbox + animaci√≥n + audio del corte.

Nodos clave:
- `Slash (Node2D)` + script `scripts/gameplay/slash.gd`.
- `Anim (AnimatedSprite2D)`: animaci√≥n del golpe.
- `Hitbox (Area2D)` + `CollisionShape2D`: detecci√≥n de impacto.
- `Sfx`, `ImpactSound` (AudioStreamPlayer2D): sonido de ataque y de impacto.

### `scenes/blood_burst.tscn`
**Rol:** explosi√≥n de sangre en GPU particles.

Nodos clave:
- `BloodBurst (GPUParticles2D)`: one-shot configurable.

### `scenes/blood_droplet.tscn`
**Rol:** gota f√≠sica que ‚Äúsalpica‚Äù y se congela como mancha.

Nodos clave:
- `BloodDroplet (RigidBody2D)` + script `scripts/fx/blood_droplet.gd`.
- `CollisionShape2D`: detecta contacto para splat.
- `Sprite2D`: textura de sangre.

### `scenes/cursor_2d.tscn`
**Rol:** cursor visual 2D que sigue al mouse.

Nodos clave:
- `MouseCursor (Node2D)`.
- `Sprite2D` + script `scripts/ui/cursor_2d.gd` (el script est√° puesto en el hijo Sprite).

---

## 3) üìå Lista de scripts principales

### `scripts/gameplay/player.gd`
- **Nodo:** `Player` (`scenes/player.tscn`).
- **Prop√≥sito:** movimiento, ataque, animaciones, da√±o/vida, muerte, knockback, blood FX y droplets.
- **Funciones clave:**
  - Movimiento con `Input.get_vector` (`move_left/right/up/down`) + aceleraci√≥n/fricci√≥n.
  - Apuntado al mouse y swing alternado con offsets izquierda/derecha.
  - Spawneo de `slash.tscn` con `setup(&"player", self)`.
  - `take_damage()`, `apply_knockback()`, `die()`, sangre y droplets.

### `scenes/enemy.gd`
- **Nodo:** `Enemy` (`scenes/enemy.tscn`).
- **Prop√≥sito:** IA t√°ctica + combate enemigo + da√±o/animaciones.
- **Funciones clave:**
  - M√°quina de estados (`IDLE`, `PATROL`, `CHASE`, `COMBAT`, `RETREAT`, `CIRCLE`, `FEINT`).
  - Detecci√≥n de player por grupo `player`.
  - Ataque con slash (`setup(&"enemy", self)`) y cooldown.
  - Hitstop sobre enemigo al recibir impacto (v√≠a slash).

### `scripts/gameplay/slash.gd`
- **Nodo:** `Slash` (`scenes/slash.tscn`).
- **Prop√≥sito:** vida corta del golpe, ventana de hitbox, aplicaci√≥n de da√±o y knockback.
- **Funciones clave:**
  - `setup(team, owner)` para friendly-fire filtering.
  - Configura `collision_mask` seg√∫n equipo (`player` pega a layer Enemy; `enemy` pega a layer Player).
  - Evita m√∫ltiples hits al mismo target con `already_hit`.
  - Aplica `take_damage`, `apply_knockback`, y opcional `apply_hitstop`.

### `scripts/gameplay/enemy_spawner.gd`
- **Nodo:** `EnemySpawner`.
- **Prop√≥sito:** spawn peri√≥dico con l√≠mite de enemigos vivos.
- **Funciones clave:**
  - Timer creado por c√≥digo.
  - Spawneo alrededor de radio configurable.
  - Contador decrementado al `tree_exited` del enemigo.

### `scripts/gameplay/main.gd`
- **Nodo:** `Main`.
- **Prop√≥sito:** estado de Game Over y reload de escena.
- **Funciones clave:**
  - `on_player_died()` pausa √°rbol y muestra panel.
  - `_on_retry_pressed()` reanuda y recarga escena.

### `scripts/camera/camera.gd`
- **Nodo:** `Camera2D` hijo del Player.
- **Prop√≥sito:** look-ahead hacia mouse + shake procedural.

### `scripts/ui/cursor_2d.gd`
- **Nodo usado:** `Sprite2D` dentro de `cursor_2d.tscn`.
- **Prop√≥sito:** ocultar cursor del SO y mover cursor visual a `get_global_mouse_position()`.

### `scripts/fx/blood_droplet.gd`
- **Nodo:** `BloodDroplet` (`RigidBody2D`).
- **Prop√≥sito:** al colisionar se congela como mancha, desactiva colisi√≥n y se limpia por tiempo.

### `scripts/fx/blood_burst.gd`
- **Nodo esperado:** no hay escena que lo use directamente hoy.
- **Prop√≥sito:** helper de spawn de part√≠culas CPU (`_spawn_blood`).
- **Observaci√≥n:** el juego actual usa `blood_burst.tscn` como `GPUParticles2D` directamente desde player/enemy.

---

## 4) üì¶ Explicaci√≥n de subsistemas

### Movimiento
- Player: locomoci√≥n con aceleraci√≥n/fricci√≥n/turn speed sobre `CharacterBody2D.velocity`.
- Enemy: locomoci√≥n seg√∫n estado de IA (persecuci√≥n, circular, retirada).
- C√°mara: offset din√°mico al mouse + smoothing.

### Ataque / combate
- Input `attack` (click izquierdo) en player.
- El ataque crea un `Slash` con hitbox activa por `hitbox_active_time` y animaci√≥n corta.
- Enemigo usa mismo prefab `Slash`, con team `enemy`.

### Part√≠culas de sangre
- **Burst:** `blood_burst.tscn` (`GPUParticles2D`) instanciado en hit/death.
- **Droplets:** `blood_droplet.tscn` (`RigidBody2D`) usado por player para salpicaduras f√≠sicas.

### IA de enemigos
- M√°quina de estados con timers t√°cticos:
  - Patrulla/espera fuera de rango,
  - Chase con predicci√≥n simple del movimiento del jugador,
  - Combat para mantener distancia ideal y atacar,
  - Retreat/circle/feint para variar comportamiento.

### Knockback / hit logic
- `slash.gd` calcula direcci√≥n desde atacante ‚Üí objetivo.
- Llama `apply_knockback(force)` si existe en target.
- Objetivos amortiguan `knock_vel` con fricci√≥n (player y enemy).
- Hitstop opcional si target implementa `apply_hitstop()` (enemigo s√≠, player no).

---

## 5) üõ† Convenciones de c√≥digo

### Nombres de variables
- Proyecto usa **snake_case** para variables/funciones (`max_speed`, `take_damage`, `_physics_process`).
- Exportadas con `@export var ...` agrupadas por `@export_group("...")`.
- Recomendaci√≥n: mantener comentarios por bloques (MOVIMIENTO, COMBATE, etc.) para legibilidad.

### Uso de grupos (`add_to_group`)
- Actualmente el player se registra en grupo `"player"` en `_ready()`.
- Enemy busca player con `get_nodes_in_group("player")`.
- Convenci√≥n recomendada:
  - Agregar grupo en `_ready()` del actor ra√≠z.
  - Usar nombre singular consistente (`"player"`, `"enemy"`, etc.).
  - No depender de rutas absolutas de nodos cuando puede usarse grupo.

### Conexiones de se√±ales
- Predominio de conexiones por c√≥digo:
  - `timer.timeout.connect(...)`
  - `button.pressed.connect(...)`
  - `hitbox.body_entered.connect(...)`
- Convenci√≥n recomendada:
  - Conectar en `_ready()`.
  - Si hay lambdas, que sean cortas y solo para cleanup/simple callbacks.
  - Para l√≥gica importante, preferir m√©todo dedicado (`_on_*`).

---

## 6) üìç C√≥mo extender el proyecto

### Agregar nuevos enemigos
1. Duplicar `scenes/enemy.tscn` y ajustar sprite/animaciones/colisi√≥n.
2. Reutilizar `scenes/enemy.gd` o crear variante heredada (ej. `enemy_ranged.gd`).
3. Exponer stats v√≠a `@export` para tunear desde inspector.
4. Asignar nuevo `enemy_scene` en `enemy_spawner.tscn` o crear spawners adicionales.

### Crear nuevas armas
1. Crear una nueva escena tipo ataque (ej. `slash_heavy.tscn`) con `Area2D` + animaci√≥n.
2. Basarte en `scripts/gameplay/slash.gd` o derivar script (da√±o, knockback, tiempo activo, SFX).
3. En el actor que ataque, cambiar `slash_scene` exportado.
4. Mantener contrato m√≠nimo de API:
   - `setup(team, owner)` para filtrar equipos.
   - Aplicar `take_damage/apply_knockback` solo si target tiene m√©todo.

### Crear nuevos efectos de sangre
1. Duplicar `blood_burst.tscn` y ajustar material (spread, velocidad, gravedad, escala).
2. O crear otra escena de droplet con f√≠sica diferente.
3. Exponer PackedScene en actor (`blood_scene`, `droplet_scene`) para alternar variantes por enemigo/player.

---

## 7) üìö Referencias r√°pidas

### Pasos para crear escenas reutilizables
1. Nodo ra√≠z con tipo correcto (`CharacterBody2D`, `Node2D`, etc.).
2. Componentes internos (sprite, colisi√≥n, audio).
3. Script en el nodo ra√≠z con variables `@export`.
4. Guardar en `scenes/` y exponer como `PackedScene` donde se instancia.

### C√≥mo hacer que un script sea reutilizable
- Evitar hardcode de paths a nodos externos.
- Usar API m√≠nima clara (`setup`, `take_damage`, `apply_knockback`).
- Separar config (`@export`) de estado interno.
- Favorecer `has_method()` para interoperabilidad entre actores distintos.

### Tips espec√≠ficos para Godot 4.4
- Usar tipado est√°tico progresivo (`var x: Type`) para menos errores.
- Revisar layers/masks en `project.godot` y en cada `Area2D/PhysicsBody2D`.
- Si se usa `Engine.time_scale` (hitstop), siempre restaurar estado con cuidado.

---

## 8) üß™ Tips para debugging

### Si no se ven part√≠culas
- Confirmar que `blood_scene` est√° asignado en inspector (player/enemy).
- Revisar que `amount`, `one_shot` y `emitting` se setean al instanciar.
- Verificar `z_index`, escala global y c√°mara (puede estar fuera de pantalla).
- Probar con `print("spawn blood", global_position)` en `_spawn_blood`.

### C√≥mo usar `print`/`prints` con contexto
- Incluir prefijo de sistema:
  - `print("[PLAYER] hp=", hp)`
  - `print("[ENEMY AI] state=", current_state)`
- Loggear al entrar/salir de estados y al conectar se√±ales para encontrar timing bugs.

### C√≥mo probar colisiones
- Activar **Debug > Visible Collision Shapes** en el editor.
- Verificar `collision_layer`/`collision_mask` de:
  - `Player` (layer Player),
  - `Enemy` (layer Enemy),
  - `Slash/Hitbox` (layer Attacks, mask din√°mico por equipo).
- Si no hay impacto:
  - confirmar `hitbox.monitoring = true` durante ventana activa,
  - revisar que target implemente `take_damage`.

---

## Notas t√©cnicas observadas durante la revisi√≥n

- Hay duplicaci√≥n de bloques de knockback/move_and_slide en `scripts/gameplay/player.gd` dentro de `_physics_process`; conviene consolidarlo para evitar aplicar fuerzas dos veces por frame.
- Existen escenas `.tmp` en `scenes/`; ideal ignorarlas en control de versiones si no son necesarias.
- `scripts/fx/blood_burst.gd` usa `CPUParticles2D`, pero el pipeline activo de sangre utiliza `GPUParticles2D` (`blood_burst.tscn`).


---

## 9) ‚úÖ Actualizaci√≥n del AGENTS.MD (estado actual del proyecto)

Esta secci√≥n agrega lo que hoy existe en el repo y no estaba expl√≠cito/centralizado en la versi√≥n inicial del documento.

### Nuevas piezas detectadas en arquitectura

- La ra√≠z de scripts est√° unificada en **`/scripts`**, con subcarpetas por dominio.
- Se incorpor√≥ un componente reutilizable de vida:
  - `scripts/components/HealthComponent.gd`
- Se incorporaron scripts de UI/HUD en uso real:
  - `scripts/ui/hud.gd`
  - `scripts/ui/hearts.gd`
- Existe adem√°s un script alternativo/legacy de corazones:
  - `scripts/ui/hearts_ui.gd` (no cableado en `main.tscn` actual).

### Escenas y nodos que ahora forman parte del flujo principal

#### `scenes/main.tscn`
Adem√°s de lo ya documentado, hoy contiene:

- `UI/HUD` con script `scripts/ui/hud.gd`.
- `UI/HUD/StaminaBar2` como `TextureProgressBar` con texturas:
  - `stamina-under.png`
  - `stamina-over..png`
  - `stamina-progress.png`
- `UI/HUD/Control/Hearts` con script `scripts/ui/hearts.gd` y texturas:
  - `heart.png`
  - `heart-empty.png`

#### `scenes/player.tscn` y `scenes/enemy.tscn`
- Ambos incluyen nodo hijo `HealthComponent` con script `scripts/components/HealthComponent.gd`.
- Esto formaliza un patr√≥n de composici√≥n para vida/da√±o y se√±ales (`damaged`, `died`).

### Sistemas agregados/expandidos respecto a la primera versi√≥n

#### Sistema de salud por componente
- `HealthComponent` encapsula:
  - `max_hp`, `hp`, `armor`
  - `take_damage(amount)` con da√±o m√≠nimo de 1
  - `heal(amount)`
  - se√±ales `damaged(amount)` y `died`
- `player.gd` puede crear el componente en runtime si falta y se conecta a sus se√±ales.
- `hearts.gd` se conecta al `HealthComponent` del player para reflejar vida en UI.

#### Sistema de stamina visible en HUD
- `player.gd` emite `stamina_changed(stamina, max_stamina)`.
- `hud.gd` busca player por grupo `"player"` y sincroniza `StaminaBar2`.
- El binding es robusto: si no existe player al inicio, reintenta en diferido.

### Script inventory actualizado (adem√°s de los ya descritos)

- `scripts/components/HealthComponent.gd` ‚Üí componente reusable de HP/armor/se√±ales.
- `scripts/ui/hud.gd` ‚Üí controlador HUD de stamina.
- `scripts/ui/hearts.gd` ‚Üí render y actualizaci√≥n de corazones por se√±ales de da√±o/muerte.
- `scripts/ui/hearts_ui.gd` ‚Üí implementaci√≥n alternativa simple de corazones (`set_hearts`).

### Convenciones adicionales importantes

- **Asumir una sola carpeta de scripts (`/scripts`)** con subcarpetas por dominio.
- Cualquier refactor de nombres/rutas debe actualizar tambi√©n `ext_resource` en escenas `.tscn`.

### Estado de assets UI (nuevo en comparaci√≥n al enfoque inicial de solo combate)

- Hearts:
  - `art/sprites/heart.png`
  - `art/sprites/heart-empty.png`
- Stamina:
  - `art/sprites/stamina-under.png`
  - `art/sprites/stamina-over..png`
  - `art/sprites/stamina-progress.png`

### Riesgos actuales a tener en cuenta

- Persisten m√∫ltiples `.tmp` en `scenes/`.
- Se mantiene coexistencia entre scripts usados y scripts alternativos no conectados (ej. `hearts_ui.gd`, `blood_burst.gd` helper).
- El bot√≥n `QUIT` del panel de game over sigue sin l√≥gica conectada.

---

## 10) üÜï Cambios recientes pendientes de registro (post actualizaci√≥n anterior)

Esta secci√≥n documenta cambios introducidos despu√©s de la √∫ltima actualizaci√≥n grande del AGENTS (la de HUD/Health), para dejar trazabilidad de arquitectura vigente.

### 10.1 Autoload de sistema global

- Se agreg√≥ **`GameManager`** como singleton en `project.godot`:
  - `[autoload] GameManager="*res://scripts/systems/game_manager.gd"`
- `GameManager` centraliza se√±ales/eventos globales del run actual:
  - `player_died`
  - `player_healed(amount)`
  - `zone_entered(zone_name)`
- Tambi√©n expone estado global inicial (`current_wave`, `gold`) para futura progresi√≥n.

### 10.2 Flujo de Game Over desacoplado v√≠a manager

- `scripts/gameplay/main.gd` ahora escucha `GameManager.player_died` en `_ready()`.
- Al recibir se√±al:
  - muestra `UI/GameOverPanel`
  - pausa el √°rbol (`get_tree().paused = true`)
  - fuerza cursor visible.
- Se mantiene m√©todo de compatibilidad `on_player_died()` que redirige al nuevo flujo basado en manager.

### 10.3 Datos de mundo formalizados en Resource

- Se a√±adi√≥ `scripts/resources/WorldData.gd` (`class_name WorldData`, `extends Resource`).
- `main.gd` exporta:
  - `world_data`
  - `world_map_size`
  - `default_tavern_position`
- En `_ready()`, `main.gd` ejecuta `_ensure_world_data()` para garantizar inicializaci√≥n.
- `WorldData` encapsula:
  - tama√±o de mapa (`map_size`)
  - posici√≥n de taberna (`tavern_position`)
  - tiles (`tile_ids`) y nodos de recurso (`resource_nodes`)
  - helpers `set_tile/get_tile` y `set_resource_amount/get_resource_amount`.

### 10.4 Stamina separada a componente reusable

- Se agreg√≥ `scripts/components/StaminaComponent.gd`.
- Responsabilidades del componente:
  - stamina m√°xima/actual
  - costo por ataque
  - regeneraci√≥n en `_physics_process`
  - API reusable:
    - `can_attack()`
    - `spend_attack_cost()`
    - `get_current_stamina()`
    - `get_max_stamina()`
  - se√±al `stamina_changed(current_stamina, max_stamina)`.

### 10.5 Integraci√≥n del Player con componentes Health + Stamina

- `player.gd` ahora pre-carga ambos componentes:
  - `HealthComponent.gd`
  - `StaminaComponent.gd`
- Si faltan en la escena, el player puede crearlos runtime (`_setup_health_component`, `_setup_stamina_component`).
- La UI de stamina se alimenta por forwarding de se√±al:
  - componente `stamina_changed` ‚Üí player `stamina_changed`.
- La l√≥gica de ataque consulta/gasta stamina mediante el componente (sin depender de variables inline de stamina en `player.gd`).

### 10.6 Convenciones nuevas a respetar

- **Eventos globales de partida**: priorizar se√±ales del `GameManager` (autoload) para evitar acoplamiento directo entre escenas.
- **Estado de mundo persistible**: usar `WorldData` como contenedor √∫nico para mapa/tiles/recursos y pasar este recurso entre sistemas.
- **Recursos jugables reutilizables**: preferir componentes (`HealthComponent`, `StaminaComponent`) frente a duplicar l√≥gica en actores.

### 10.7 Sistema m√≠nimo de Inventario + Monedas (MVP sin UI)

- Se a√±adi√≥ `scripts/components/InventoryComponent.gd` como componente reusable (`Node`) para econom√≠a base.
- Estado encapsulado:
  - `gold: int`
  - `items: Dictionary` (`item_id -> cantidad`)
- API gen√©rica implementada para loop minar/vender/comprar:
  - `add_item`, `remove_item`, `get_count`, `sell_item`, `sell_all`, `buy_item`, `debug_print`.
- Reglas clave:
  - Sin hardcode de recursos (ej. `"copper"` se maneja como `item_id` string).
  - Upgrades quedan fuera del inventario (se tratar√°n en otro sistema).
  - Flujo de prueba por `print()` sin UI.
- Integraci√≥n en `scripts/gameplay/player.gd`:
  - preload del nuevo componente y creaci√≥n runtime si falta como hijo `InventoryComponent`.
  - hotkeys de test en `_input`:
    - `KEY_1`: `add_item("copper", 3)`
    - `KEY_2`: `sell_all("copper", 5)`
    - `KEY_3`: `buy_item("medkit", 1, 20)`
    - `KEY_4`: cheat `gold += 50`
  - tras cada acci√≥n se llama `inventory.debug_print()`.
# Registro de cambios desde la √∫ltima actualizaci√≥n de `AGENTS.MD`

Fecha de corte usada: √∫ltimo commit que modific√≥ `AGENTS.MD`.

- **Commit de referencia (√∫ltima actualizaci√≥n de AGENTS):** `f8d6a2f` ‚Äî *Add reusable inventory component and player debug hotkeys* (2026-02-17).
- **Rango auditado:** `f8d6a2f..HEAD`.

## Resumen ejecutivo

Despu√©s de la √∫ltima actualizaci√≥n de `AGENTS.MD`, el proyecto evolucion√≥ principalmente en 3 frentes:

1. **Combate defensivo del player** (bloqueo con stamina y cono de bloqueo).
2. **Sistema de mundo por chunks** (streaming, generaci√≥n y persistencia de entidades).
3. **Nuevo contenido de mundo/miner√≠a** (cobre, campamentos bandido, tiles y audio de minado).

---

## Cambios por commit (semi breve)

### `55c6f1a` ‚Äî Add stamina-based blocking behavior to player
- Se a√±adi√≥ el **bloqueo** al jugador dentro de `player.gd`.
- El bloqueo consume/depende de stamina e introduce l√≥gica defensiva directa en combate.
- Impacto: mejora supervivencia del player y abre decisiones t√°cticas (atacar vs bloquear).

Archivos:
- `scripts/gameplay/player.gd`

### `d496823` ‚Äî Sistema de bloqueo con cono + ajuste stamina
- Se refin√≥ el sistema de bloqueo con **cono frontal** (bloqueo direccional).
- Se ajust√≥ la integraci√≥n con stamina y la configuraci√≥n de input/proyecto.
- Tambi√©n hubo ajustes en escenas principales (`main`, `player`) y metadatos `.uid`.
- Impacto: defensa m√°s precisa y menos ‚Äúbloqueo universal 360¬∞‚Äù.

Archivos principales:
- `project.godot`
- `scenes/main.tscn`
- `scenes/player.tscn`
- `scripts/components/StaminaComponent.gd`
- `scripts/gameplay/player.gd`

### `a193bd0` ‚Äî world + chunk system + copper + bandit camps working
- Se incorpor√≥ el n√∫cleo del **mundo por chunks** (`scripts/world/world.gd`).
- Se agregaron recursos/miner√≠a de **cobre** y escena/scripts asociados.
- Se agregaron **campamentos de bandidos** con escena/script dedicados.
- Se incorporaron nuevos assets visuales/sonoros (tiles, sprites, audio de minado).
- Impacto: salto de prototipo de combate a loop de exploraci√≥n/recolecci√≥n en mundo m√°s grande.

Archivos principales:
- `scripts/world/world.gd`
- `scripts/resources/copper_ore.gd`
- `scripts/world/bandit_camp.gd`
- `scenes/copper_ore.tscn`
- `scenes/bandit_camp.tscn`
- `art/tiles/terrain.tres`
- `art/Sounds/mining.ogg`

### `eec0ffa` ‚Äî Implement chunk entity save/load persistence
- Se a√±adi√≥ **persistencia de entidades por chunk** (guardar/cargar estado).
- Reduce p√©rdida de estado al salir/entrar de chunks.
- Impacto: mundo m√°s consistente durante la sesi√≥n y base para guardado m√°s completo.

Archivos:
- `scripts/world/world.gd`

### `66be7c9` ‚Äî Improve world chunk streaming performance
- Se optimiz√≥ el **streaming de chunks** para reducir lag/microcortes.
- Ajustes adicionales en `player.gd` y `blood_droplet.gd` para acompa√±ar rendimiento/flujo.
- Impacto: experiencia m√°s fluida en desplazamiento por mapa.

Archivos:
- `scripts/world/world.gd`
- `scripts/gameplay/player.gd`
- `scripts/fx/blood_droplet.gd`

---

## Commits de merge en el rango (trazabilidad)

- `d233b34` ‚Äî Merge PR #19 (inventory)
- `d551f45` ‚Äî Merge PR #20 (blocking)
- `4b75ebf` ‚Äî Merge PR #21 (chunk save/load)
- `ee36bc9` ‚Äî Merge PR #22 (lag fixes world)

> Nota: estos commits consolidan ramas/PRs; los cambios t√©cnicos est√°n reflejados arriba en los commits funcionales.

---

## Conclusi√≥n r√°pida

Desde la √∫ltima actualizaci√≥n de `AGENTS.MD`, el proyecto pas√≥ de mejoras de combate local a una fase m√°s de **mundo sist√©mico**:
- defensa del player m√°s avanzada,
- loop de miner√≠a/contenido de mundo,
- arquitectura de chunks con persistencia y optimizaci√≥n de rendimiento.

